// *****************************************************************************
//
// Copyright (c) 2015, Southwest Research Institute速 (SwRI速)
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Southwest Research Institute速 (SwRI速) nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// *****************************************************************************

#include <mapviz_plugins/laserscan_plugin.h>

// C++ standard libraries
#include <cmath>
#include <cstdio>
#include <algorithm>
#include <vector>

// Boost libraries
#include <boost/algorithm/string.hpp>

// QT libraries
#include <QColorDialog>
#include <QDialog>
#include <QGLWidget>

// OpenGL
#include <GL/glew.h>

// QT Autogenerated
#include "ui_topic_select.h"

// ROS libraries
#include <ros/master.h>

#include <math_util/constants.h>
#include <yaml_util/yaml_util.h>


// Declare plugin
#include <pluginlib/class_list_macros.h>
PLUGINLIB_DECLARE_CLASS(
    mapviz_plugins,
    laserscan,
    mapviz_plugins::LaserScanPlugin,
    mapviz::MapvizPlugin)

namespace mapviz_plugins
{
  LaserScanPlugin::LaserScanPlugin() :
      config_widget_(new QWidget()),
      topic_(""),
      min_color_(0, 0, 0, 0),
      max_color_(255, 255, 255, 0),
      alpha_(1.0),
      decay_time_(0.0),
      value_min_(0.0),
      value_max_(100.0)
  {
    ui_.setupUi(config_widget_);

    // Set background white
    QPalette p(config_widget_->palette());
    p.setColor(QPalette::Background, Qt::white);
    config_widget_->setPalette(p);

    // Set status text red
    QPalette p3(ui_.status->palette());
    p3.setColor(QPalette::Text, Qt::red);
    ui_.status->setPalette(p3);

    // Set color transformer choices

    ui_.color_transformer->addItem(QString("Flat Color"), QVariant(0));
    ui_.color_transformer->addItem(QString("Intensity"), QVariant(1));
    ui_.color_transformer->addItem(QString("Range"), QVariant(2));
    ui_.color_transformer->addItem(QString("X Axis"), QVariant(3));
    ui_.color_transformer->addItem(QString("Y Axis"), QVariant(4));
    ui_.color_transformer->addItem(QString("Z Axis"), QVariant(5));

    QObject::connect(ui_.selecttopic,
                      SIGNAL(clicked()),
                      this,
                      SLOT(SelectTopic()));
    QObject::connect(ui_.topic,
                      SIGNAL(editingFinished()),
                      this,
                      SLOT(TopicEdited()));
    QObject::connect(ui_.alpha,
                      SIGNAL(editingFinished()),
                      this,
                      SLOT(AlphaEdited()));
    QObject::connect(ui_.decay,
                      SIGNAL(editingFinished()),
                      this,
                      SLOT(DecayTimeEdited()));
    QObject::connect(ui_.color_transformer,
                      SIGNAL(currentIndexChanged(int)),
                      this,
                      SLOT(ColorTransformerChanged(int)));
    QObject::connect(ui_.selectmaxcolor,
                      SIGNAL(clicked()),
                      this,
                      SLOT(SelectMaxColor()));
    QObject::connect(ui_.selectmincolor,
                      SIGNAL(clicked()),
                      this,
                      SLOT(SelectMinColor()));
  }

  LaserScanPlugin::~LaserScanPlugin()
  {
  }

  void LaserScanPlugin::SelectTopic()
  {
    QDialog dialog;
    Ui::topicselect ui;
    ui.setupUi(&dialog);

    std::vector<ros::master::TopicInfo> topics;
    ros::master::getTopics(topics);

    for (unsigned int i = 0; i < topics.size(); i++)
    {
      if (topics[i].datatype == "sensor_msgs/LaserScan")
      {
        ui.displaylist->addItem(topics[i].name.c_str());
      }
    }
    ui.displaylist->setCurrentRow(0);

    dialog.exec();

    if (dialog.result() == QDialog::Accepted &&
        ui.displaylist->selectedItems().count() == 1)
    {
      ui_.topic->setText(ui.displaylist->selectedItems().first()->text());
      TopicEdited();
    }
  }

  void LaserScanPlugin::TopicEdited()
  {
    if (ui_.topic->text().toStdString() != topic_)
    {
      initialized_ = false;
      scans_.clear();
      has_message_ = false;
      topic_ = boost::trim_copy(ui_.topic->text().toStdString());
      PrintWarning("No messages received.");

      laserscan_sub_.shutdown();
      laserscan_sub_ = node_.subscribe(topic_,
                                       100,
                                       &LaserScanPlugin::laserScanCallback,
                                       this);

      ROS_INFO("Subscribing to %s", topic_.c_str());
    }
  }

  void LaserScanPlugin::laserScanCallback(const sensor_msgs::LaserScanConstPtr& msg)
  {
    if (!has_message_)
    {
      source_frame_ = msg->header.frame_id;
      initialized_ = true;
      has_message_ = true;
    }

    Scan scan;
    scan.stamp = msg->header.stamp;
    scan.transformed = true;

    scan.points.clear();

    transform_util::Transform transform;
    if (!GetTransform(msg->header.stamp, transform))
    {
      scan.transformed = false;
      PrintError("No transform between " +
          source_frame_ + " and " + target_frame_);
    }
    double angle, x, y;
    for (unsigned int i = 0; i < msg->ranges.size(); i++)
    {
      // Discard the point if it's out of range
      if (msg->ranges[i] > msg->range_max || msg->ranges[i] < msg->range_min)
      {
        continue;
      }
      StampedPoint point;
      angle = msg->angle_min + msg->angle_increment * i;
      x = cos(angle) * msg->ranges[i];
      y = sin(angle) * msg->ranges[i];
      point.point = tf::Point(x, y, 0.0f);
      point.range = msg->ranges[i];
      point.transformed_point = transform * point.point;
      if (i < msg->intensities.size())
        point.intensity = msg->intensities[i];
      scan.points.push_back(point);
    }
    scans_.push_back(scan);

    canvas_->update();
  }

  void LaserScanPlugin::PrintError(const std::string& message)
  {
    if (message == ui_.status->text().toStdString())
      return;

    ROS_ERROR("Error: %s", message.c_str());
    QPalette p(ui_.status->palette());
    p.setColor(QPalette::Text, Qt::red);
    ui_.status->setPalette(p);
    ui_.status->setText(message.c_str());
  }

  void LaserScanPlugin::PrintInfo(const std::string& message)
  {
    if (message == ui_.status->text().toStdString())
      return;

    ROS_INFO("%s", message.c_str());
    QPalette p(ui_.status->palette());
    p.setColor(QPalette::Text, Qt::green);
    ui_.status->setPalette(p);
    ui_.status->setText(message.c_str());
  }

  void LaserScanPlugin::PrintWarning(const std::string& message)
  {
    if (message == ui_.status->text().toStdString())
      return;

    ROS_WARN("%s", message.c_str());
    QPalette p(ui_.status->palette());
    p.setColor(QPalette::Text, Qt::darkYellow);
    ui_.status->setPalette(p);
    ui_.status->setText(message.c_str());
  }

  QWidget* LaserScanPlugin::GetConfigWidget(QWidget* parent)
  {
    config_widget_->setParent(parent);

    return config_widget_;
  }

  bool LaserScanPlugin::Initialize(QGLWidget* canvas)
  {
    canvas_ = canvas;

    return true;
  }

  void LaserScanPlugin::Draw(double x, double y, double scale)
  {
    ros::Time now = ros::Time::now();

    glPointSize(ui_.size->text().toUInt());
    glBegin(GL_POINTS);

    std::list<Scan>::iterator scan_it = scans_.begin();
    QColor color = min_color_;
    // TODO(evenator): Use min color for this
    while (scan_it != scans_.end())
    {
      Scan& scan = *scan_it;
      // Remove expired scan
      if ((now - scan.stamp).toSec() > decay_time_)
      {
        // Special case: If decay time is zero, don't erase
        // the last scan
        if (decay_time_ > 0.0f || scans_.size() > 1)
        {
          scan_it = scans_.erase(scan_it);
          continue;
        }
      }
      if (scan.transformed)
      {
        std::list<StampedPoint>::iterator point_it = scan.points.begin();
        for (; point_it != scan.points.end(); ++point_it)
        {
          switch (ui_.color_transformer->currentIndex())
          {
            case 1:  // Intensity
              color = ValueToColor(point_it->intensity);
              break;
            case 2:  // Range
              color = ValueToColor(point_it->range);
              break;
            case 3:  // X
              color = ValueToColor(point_it->point.getX());
              break;
            case 4:  // Y
              color = ValueToColor(point_it->point.getY());
              break;
            case 5:  // Z
              color = ValueToColor(point_it->transformed_point.getZ());
              break;
          }
          glColor4f(color.redF(), color.greenF(), color.blueF(), alpha_);
          glVertex2f(point_it->transformed_point.getX(),
              point_it->transformed_point.getY());
        }
      }
      scan_it++;
    }
    glEnd();

    PrintInfo("OK");
  }

  QColor LaserScanPlugin::ValueToColor(float val)
  {
    float value_max = ui_.value_max->text().toFloat();
    float value_min = ui_.value_min->text().toFloat();
    if (value_max > value_min)
      val = (val - value_min) / (value_max - value_min);
    val = std::max(0.0f, std::min(val, 1.0f));
    if (ui_.use_rainbow->isChecked())
    {
      int hue = val * 255;
      return QColor::fromHsl(hue, 255, 127, 255);
    }
    else
    {
      int red, green, blue;
      red = val * max_color_.red() + ((1.0 - val) * min_color_.red());
      green = val * max_color_.green() + ((1.0 - val) * min_color_.green());
      blue = val * max_color_.blue() + ((1.0 - val) * min_color_.blue());
      return QColor(red, green, blue, 255);
    }
  }

  void LaserScanPlugin::SelectMaxColor()
  {
    QColorDialog dialog(max_color_, config_widget_);
    dialog.exec();

    if (dialog.result() == QDialog::Accepted)
    {
      max_color_ = dialog.selectedColor();
      ui_.selectmaxcolor->setStyleSheet("background: " + max_color_.name() + ";");
      canvas_->update();
    }
  }

  void LaserScanPlugin::SelectMinColor()
  {
    QColorDialog dialog(min_color_, config_widget_);
    dialog.exec();

    if (dialog.result() == QDialog::Accepted)
    {
      min_color_ = dialog.selectedColor();
      ui_.selectmincolor->setStyleSheet("background: " + min_color_.name() + ";");
      canvas_->update();
    }
  }

  void LaserScanPlugin::Transform()
  {
    std::list<Scan>::iterator scan_it = scans_.begin();
    for (; scan_it != scans_.end(); scan_it++)
    {
      transform_util::Transform transform;
      if (GetTransform(scan_it->stamp, transform))
      {
        scan_it->transformed = true;

        std::list<StampedPoint>::iterator point_it = scan_it->points.begin();
        for (; point_it != scan_it->points.end(); ++point_it)
        {
          point_it->transformed_point = transform * point_it->point;
        }
      }
      else
      {
        scan_it->transformed = false;
      }
    }
  }

  void LaserScanPlugin::LoadConfig(const YAML::Node& node,
                                       const std::string& path)
  {
    std::string topic;
    node["topic"] >> topic;
    ui_.topic->setText(boost::trim_copy(topic).c_str());
    TopicEdited();

    std::string size;
    node["size"] >> size;
    ui_.size->setText(size.c_str());

    std::string alpha;
    node["alpha"] >> alpha;
    ui_.alpha->setText(alpha.c_str());
    AlphaEdited();

    std::string decay;
    node["decay_time"] >> decay;
    ui_.decay->setText(decay.c_str());
    DecayTimeEdited();

    std::string color_transformer;
    node["color_transformer"] >> color_transformer;
    if (color_transformer == "Intensity")
      ui_.color_transformer->setCurrentIndex(1);
    else if (color_transformer == "Range")
      ui_.color_transformer->setCurrentIndex(2);
    else if (color_transformer == "X Axis")
      ui_.color_transformer->setCurrentIndex(3);
    else if (color_transformer == "Y Axis")
      ui_.color_transformer->setCurrentIndex(4);
    else if (color_transformer == "Z Axis")
      ui_.color_transformer->setCurrentIndex(5);
    else
      ui_.color_transformer->setCurrentIndex(0);
    ColorTransformerChanged(ui_.color_transformer->currentIndex());

    std::string min_color_str;
    node["min_color"] >> min_color_str;
    min_color_ = QColor(min_color_str.c_str());
    ui_.selectmincolor->setStyleSheet("background: " + min_color_.name() + ";");

    std::string max_color_str;
    node["max_color"] >> max_color_str;
    max_color_ = QColor(max_color_str.c_str());
    ui_.selectmaxcolor->setStyleSheet("background: " + max_color_.name() + ";");

    std::string value_min;
    node["value_min"] >> value_min;
    ui_.value_min->setText(value_min.c_str());

    std::string value_max;
    node["value_max"] >> value_max;
    ui_.value_max->setText(value_max.c_str());

    bool use_rainbow;
    node["use_rainbow"] >> use_rainbow;
    ui_.use_rainbow->setChecked(use_rainbow);
  }

  void LaserScanPlugin::ColorTransformerChanged(int index)
  {
    ROS_DEBUG("Color transformer changed to %d", index);
    switch (index)
    {
      case 0:  // Flat color
        ui_.selectmaxcolor->setVisible(false);
        ui_.maxcolor_label->setVisible(false);
        ui_.mincolor_label->setText("Color");
        ui_.bounds_label->setVisible(false);
        ui_.value_max->setVisible(false);
        ui_.value_max_label->setVisible(false);
        ui_.value_min->setVisible(false);
        ui_.value_min_label->setVisible(false);
        ui_.use_rainbow->setVisible(false);
        break;
      case 1:  // Intensity
      case 2:  // Range
      case 3:  // X Axis
      case 4:  // Y Axis
      case 5:  // Z axis
      default:
        ui_.selectmaxcolor->setVisible(true);
        ui_.maxcolor_label->setVisible(true);
        ui_.mincolor_label->setText("Min Color:");
        ui_.bounds_label->setVisible(true);
        ui_.value_max->setVisible(true);
        ui_.value_max_label->setVisible(true);
        ui_.value_min->setVisible(true);
        ui_.value_min_label->setVisible(true);
        ui_.use_rainbow->setVisible(true);
        break;
    }
  }

  /**
   * Coerces alpha to [0.0, 1.0] and stores it in alpha_
   */
  void LaserScanPlugin::AlphaEdited()
  {
    alpha_ = std::max(0.0f, std::min(ui_.alpha->text().toFloat(), 1.0f));
    ui_.alpha->setText(QString::number(alpha_));
  }

  /**
   * Coerces decay time to non-negative and stores it in decay_time_
   * 0 decay time displays most recent scan only
   */
  void LaserScanPlugin::DecayTimeEdited()
  {
    decay_time_ = std::max(0.0f, ui_.decay->text().toFloat());
    ui_.decay->setText(QString::number(decay_time_));
  }

  void LaserScanPlugin::SaveConfig(YAML::Emitter& emitter, const std::string& path)
  {
    emitter << YAML::Key << "topic" <<
               YAML::Value << boost::trim_copy(ui_.topic->text().toStdString());
    emitter << YAML::Key << "size" <<
               YAML::Value << ui_.size->text().toInt();
    emitter << YAML::Key << "alpha" <<
               YAML::Value << alpha_;
    emitter << YAML::Key << "decay_time" <<
               YAML::Value << decay_time_;
    emitter << YAML::Key << "color_transformer" <<
               YAML::Value << ui_.color_transformer->currentText().toStdString();
    emitter << YAML::Key << "min_color" <<
               YAML::Value << min_color_.name().toStdString();
    emitter << YAML::Key << "max_color" <<
               YAML::Value << max_color_.name().toStdString();
    emitter << YAML::Key << "value_min" <<
               YAML::Value << ui_.value_min->text().toFloat();
    emitter << YAML::Key << "value_max" <<
               YAML::Value << ui_.value_max->text().toFloat();
    emitter << YAML::Key << "use_rainbow" <<
               YAML::Value << ui_.use_rainbow->isChecked();
  }
}

